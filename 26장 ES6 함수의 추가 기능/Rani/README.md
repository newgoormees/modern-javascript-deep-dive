## 메서드

ES6의 메서드는 메서드 축약 표현으로 정의된 함수만을 의미하며, 인스턴스를 생성할 수 없는 non-constructor임

따라서 생성자 함수로서 호출할 수 없음

```tsx
const obj = {
	foo() { };
	bar: function() { };
}
```

위의 경우,

new [obj.foo](http://obj.foo)(); → `obj.foo is not a constructor TypeError`

new obj.bar();

이처럼 메서드는 생성자 함수로서 호출할 수 없음

인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고, 프로토타입을 생성하지도 않음

ES6는 super키워드를 사용할 수 있으나, 아닌 함수들은 사용할 수 없음

(내부 슬롯 [[HomeObject]]를 가지지 않기 때문)

## 화살표 함수

- 화살표 함수는 함수 선언문으로 정의할 수 없음
- 매개변수가 한 개인 경우 x ⇒ x * 2와 같이 생략 가능
- 함수 몸체가 하나의 문으로 구성된다면 중괄호 생략 가능, 값으로 표현되는 문이라면 암묵적으로 반환되지만 그렇지 않을 경우 반환할 수 없어 에러 발생
    - 그러나 객체 리터럴을 반환할 경우 소괄호로 감싸 주어야 함
    - 예) const fn = () ⇒ { ‘a’: 1, ‘b’: 2 }

### 일반 함수 vs 화살표 함수

- 화살표 함수는 생성자 함수로서 호출 불가능
    
    ```tsx
    const foo = () => {};
    new Foo(); -> TypeError 발생
    ```
    
- 화살표 함수는 prototype 프로퍼티가 없음
- 화살표 함수는 중복된 매개변수 이름을 선언할 수 없음
    - 예) function fn (a, a) { return a + a; } → `pass` (strict mode는 에러 발생)
    - 예) const fn - (a, a) ⇒ a + a; → `error`
    

## this

화살표 함수의 this는 일반 함수의 this와 다름

this바인딩은 일반적으로 this에 바인딩할 객체가 정적으로 결정되는 것이 아니라, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 동적으로 결정됨

## Rest 파라미터

- 반드시 마지막 파라미터여야 한다
- 단 하나만 선언할 수 있다
- 나머지 인수들을 의미한다
- 화살표 함수로 가변 인자 함수를 구현할 경우 반드시 Rest 파라미터를 사용해야 한다. 화살표 함수는 함수 자체의 arguments를 갖지 않기 때문
    - arguments: 호출시 전달된 인수들을 담고 있는 유사 배열 객체 - 유사 배열 객체이므로 배열 메서드를 직접적으로 사용할 수 없음

## 매개변수 기본값

- 함수 호출시 매개변수 개수만큼 인수를 맞추어 전달하지 않아도 에러 발생하지 않음 - 자바스크립트 엔진이 매개변수 개수와 인수 개수를 체크하지 않기 때문
- 인수가 전달되지 않은 매개변수의 값은 undefined
- ES6에서는 이를 막기위해 매개변수 기본값을 도입함 - 인수를 전달하지 않거나 undefined가 전달된 경우 기본값으로 할당됨
    
    ```tsx
    function sum(x=0, y=0)
    ```
