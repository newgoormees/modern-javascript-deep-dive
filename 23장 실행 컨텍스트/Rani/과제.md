# 23. 실행 컨텍스트

- `실행 컨텍스트(execution context)` : JS 동작 원리를 담고 있는 핵심 개념
- ┣ 실행 컨텍스트 바르게 이해 → JS가
- ┣ 1. 식별자와 식별자에 바인딩 값(식별자 바인딩)을 관리하는 방법
- ┣ 2. 호이스팅이 발생하는 이유
- ┣ 3. 클로저의 동작 방식
- ┣ 4. 태스크 큐와 함께 동작하는 이벤트 핸들러
- ┗ 5. 비동기 처리의 동작 방식 이해 가능


[소스코드의 타입]
| 전역 코드(global code)   | 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함 X
| 함수 코드(function code) | 함수 내부에 존재하는 소스코드를 말함. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 포함 X
| eval 코드(eval coe)      | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 코드를 말함
| 모듈 코드(module code)   | 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드 포함 X

- `소스코드(실행 가능한 코드)`를 `4가지 타입으로 구분` 이유 :
- ┣ 소스코드의 타입에 따라 `실행 컨텍스트를 생성하는 과정`과
- ┗ `관리 내용`이 다르기 때문

1. 전역 코드

- `전역 코드` : `전역 변수를 관리`하기 위해 최상위 스코프인 `전역 스코프를 생성`
- ┣ `var 키워드`로 선언된 `전역 변수`, `함수 선언문`으로 정의된 `전역 함수`를
- ┣ `객체의 프로퍼티와 메서드로 바인딩`하고, `참조`하기 위해 `전역 객체와 연결`
- ┗ 이를 위해 `전역 코드가 평가` → `전역 실행 컨텍스트`가 생성

2. 함수 코드

- `함수 코드` : `지역 스코프`를 생성, `지역 변수`, `매개변수`, `arguments 객체를 관리` 해야 함
- ┣ 생성한 지역 스코프 → `전역 스코프에서 시작하는 스코프 체인의 일원`으로 연결
- ┗ 이를 위해 `함수 코드가 실행` → `함수 실행 컨텍스트`가 생성

3. eval 코드

- `eval 코드` : `strict mode`에서 `자신만의 독자적인 스코프`를 생성
- ┗ 이를 위해 `eval 코드 동작` → `eval 실행 컨텍스트`가 생성

4. 모듈 코드

- `모듈 코드`는 `모듈별로 독립적인 모듈 스코프`를 생성
- ┗ 이를 위해 `모듈 코드가 평`가되면 `모듈 실행 컨텍스트 생성`


## 23.2 실행 컨텍스트의 역할

- 다음 예제 : 전역 코드, 함수 코드로 구성
- JS가 이 예제를 어떻게 평가하고 실행할지 생각

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
	const x = 10;
	const y = 20;

	// 메서드 호출
	console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

### 1. 전역 코드 평가

- 전역 코드 실행에 앞서
- ┣ 먼저 전역 코드 평가 과정을 거치며
- ┣ `전역 코드를 실행`하기 위한 `준비`를 함
- ┣ `소스코드 평가 과정` : `선언문만 먼저 실행`
- ┣ 전역 코드의 `변수 선언문`, `함수 선언문`이 먼저 실행
- ┣ 그 결과 : 생성된 1. `전역 변수`, 2. `전역함수`가
- ┣ `실행 컨턱스트가 관리`하는 → `전역 스코프`에 등록
- ┣ 이때 var 키워드로 선언된 `전역 변수와 함수 선언문`으로
- 정의된 `전역 함수` : `전역 객체의 프로퍼티와 메서드`가 됨

### 2. 전역 코드 실행

- `전역 코드 평가 과정 끝` →
- ┣ `런타임이 시작`되어 `전역 코드가 순차적으로 실행`
- ┣ `전역 변수에 값이 할당`되고 `함수가 호출`됨
- ┣ `함수가 호출`되면 순차적으로 실행되던
- ┣ 전역 코드의 `실행을 일시 중단`
- ┗ `코드 실행 순서를 변경`하여 `함수 내부로 진입`

### 3. 함수 코드 평가

- 함수 호출에 의해 : `코드 실행 순서가 변경`되어
- ┣ 함수 내부로 진입하면 → 함수 내부의 문들을
- ┣ 실행하기에 앞서 `함수 코드 평가 과정`을 거치며
- ┣ `함수 코드를 실행하기 위한 준비`를 함
- ┗ `매개변수`와 `지역 변수 선언문`이 `먼저 실행`

- 그 결과 : `생성된 매개변수`와 `지역 변수`가
- ┣ `실행 컨텍스트가 관리`하는 `지역 스코프에 등록`
- ┣ 함수 내부에서 `지역 변수처럼 사용할 수 있는`
- ┣ `arguments 객체`가 생성되어
- ┗ `지역 스코프에 등록`, `this 바인딩 결정`

### 4. 함수 코드 실행

- 함수 코드 과정이 끝나면
- ┣ `런타임 시작` → `함수 코드가 순차적으로 실행`됨
- ┣ 이때 `매개변수`와 `지역 변수에 값이 할당`
- ┗ `console.log` `메서드가 호출`

- `console.log` 메서드 호출하기 위해서
- ┣ 먼저 식별자인 console → `스코프 체인을 통해 검색`
- ┣ 이를 위해 함수 코드의 지역 스코프 :
- ┗ `상위 스코프인 전역 스코프와 연결`되어야 함

- ┣ 하지만 console 식별자 :
- ┣ `스코프 체인 등록 X` → `전역 객체 프로퍼티`로 존재
- ┣ 이는 `전역 객체의 프로퍼티가 마치 전역 변수`처럼
- ┗ `전역 스코프를 통해 검색 가능`해야 한다는 것을 의미

- `log 프로퍼티`를 console 객체의 프로토타입 체인을 통해 검색
- ┣ `console.log` 메서드에 인수로 전달된 표현식
- ┣ `a + x + y`가 평가
- ┣ a, x, y 식별자 : 스코프 체인을 통해 검색
- ┣ `console.log` 메서드의 실행이 종료
- ┣ 함수 코드의 실행 과정 종료되고, `함수 호출 이전으로 되돌아가`
- ┗ `전역 코드의 실행을 계속`하게 됨

> 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 관리 필요

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스)를

   - ┣ 1) `스코프를 구분하여 등록`하고
   - ┣ 2) `상태 변화(식별자에 바인딩된 값의 변화)`를
   - ┗ `지속적으로 관리` 가능해야 함

2. `스코프를 중첩 관계에 의해 스코프 체인`을 형성

   - ┣ 스코프 체인을 통해 → `상위 스코프로 이동`
   - ┗ `식별자를 검색`할 수 있어야 함

3. 현재 실행 중인 코드의 `실행 순서를 변경`
   - ┣ (함수 호출에 의한 실행 순서 변경)
   - ┣ 할 수 있어야 하며
   - ┗ `원상복구도 가능`해야 함

- 이 모든 것을 관리하는 것이 : 실행 컨텍스트

- `실행 컨텍스트` : 소스코드를 실행하는데
- ┣ 1. `필요한 환경을 제공`하고
- ┗ 2. `실행 결과를 실제로 관리`하는 영역

- `구체적으로 실행 컨텍스트` :
- ┣ 1. `식별자(변수, 함수, 클래스)`를 `등록`, `관리`하고
- ┣ 2. `스코프와 코드 실행 순서` 관리를 구현한 `내부 매커니즘`
- ┗ `모든 코드` : `실행 컨텍스트를 통해 실행되고 관리`

- `식별자, 스코프` : `실행 컨텍스트의 렉시컬 환경`으로 관리
- ┗ 코드 `실행 순서` : `실행 컨텍스트 스택`으로 관리

## 23.4 실행 컨텍스트 스택

- 다음 예제

```js
const x = 1;

function foo() {
	const y = 2;

	function bar() {
		const z = 3;
		console.log(x + y + z);
	}
	bar();
}

foo(); // 6
```

- 위 예제 : `소스코드의 타입으로 분류`할 때
- ┣ `전역 코드, 함수 코드`로 이루어져 있음
- ┣ JS엔진 : `먼저 전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`함
- ┣ 함수가 호출되면 `함수 코드를 평가`하여
- ┗ `함수 실행 컨텍스트를 생성`

- 생성된 실행 컨텍스트 : `스택 자료구조로 관리`
- ┣ 이를 → 스택 컨텍스트 스택
- ┣ 코드가 실행되는 시간의 흐름에 따라
- ┗ 실행 컨텍스트에 push, pop 됨

### 1. 전역 코드의 평가와 실행

- `JS엔진` : 먼저 `전역 코드를 평가`하여
- ┣ `전역 실행 컨텍스트를 생성`하고
- ┣ 실행 컨텍스트 스택에 푸시함
- ┣ 전역 변수 x, `전역 함수 foo는 전역 실행 컨텍스트에 등록`
- ┣ `전역 코드가 실행되기 시작`하여
- ┗ 전역 변수 x에 `값이 할당`, `전역 함수` foo가 `호출`

### 2. foo 함수 코드의 평가와 실행

- `전역 함수 foo가 호출` → 전역 코드의 `실행은 일시 중단`
- ┣ `코드의 제어권`이 : `foo 함수 내부로 이동`하게 됨
- ┣ `JS엔진` : `foo 함수 내부의 코드를 평가`하여 →
- ┣ 1. `foo 함수 실행 컨텍스트를 생성`
- ┣ 2. `실행 컨텍스트 스택에 푸시`
- ┣ foo 함수의 지역 변수 y와 중첩 함수 bar가
- ┣ foo 함수 실행 컨텍스트에 등록됨
- ┗ 이후 foo 함수 코드가 실행되기 시작하며 지역 변수 y 할당, 중첩함수 호출

### 3. bar 함수 코드의 평가와 실행

- 중첩 함수 `bar가 호출되면 foo 함수 코드의 실행`은
- ┣ 일시 중단되고, 코드의 제어권이 bar 함수 내부로 이동함
- ┣ `JS엔진` : `bar 함수 내부의 함수 코드를 평가`하여
- ┣ `bar 함수 실행 컨텍스트를 생성`하고
- ┣ `실행 컨텍스트 스택에 푸시`
- ┣ `bar 함수의 지역 변수` z : `bar 함수 실행 컨텍스트`에 등록
- ┣ bar 함수 코드가 실행되기 시작하여
- ┣ 지역 변수 z에 값이 할당, console.log 메서드를 호출한 이후
- ┗ bar 함수는 종료

### 4. foo 함수 코드로 복귀

- bar 함수가 종료되면
- ┣ 코드의 제어권 : 다시 foo 함수로 이동
- ┣ 이때 : JS엔진 → bar 함수 실행 컨텍스트를
- ┣ 실행 컨텍스트 스택에서 팝하여 제거함
- ┗ 결국 foo 함수 더 이상 실행할 코드가 없어서 종료

### 5. 전역 코드로 복귀

- foo 함수가 종료되면
- ┣ 코드의 제어권 : 다시 전역 코드로 이동하게 됨
- ┣ JS 엔진 : foo 함수 실행 컨텍스트 팝하여 제거
- ┗ 결국 실행 컨텍스트 스택에는 아무것도 남아있지 않게됨



### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 `JS 엔진` : `전역 코드를 평가함`
- ┗ 전역 코드 평가는 다음과 같은 순서로 진행

1. 전역 실행 컨텍스트 생성

2. 전역 렉시컬 환경 생성
   - 2.1 전역 환경 레코드 생성
     - 2.1.1 객체 환경 레코드 생성
     - 2.1.2 선언적 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

###### 2.2 this 바인딩

- 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에
- ┣ this가 바인딩됨
- ┣ 일반적으로 전역 코드 this → 전역 객체를 가리킴
- ┣ 전역 코드에서 this를 참조하면 전역 환경 레코드의
- ┣ `[[GlobalThisValue]]` `내부 슬롯에 바인딩`되어 있는
- ┗ `객체가 반환`됨

- `전역 환경 레코드를 구성`하는 :
- ┣ 1. `객체 환경 레코드`와
- ┣ 2. `선언적 환경 레코드`에는
- ┗ `this 바인딩이 없음`

- `this 바인딩` : 1. `전역 환경 레코드`와
- ┗ 2. `함수 환경 레코드`에만 존재

###### 2.3 외부 렉시컬 환경에 대한 참조 결정

- `외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)`
- ┣ `현재 평가 중인 소스코드를 포함`하는 `외부 소스코드의 렉시컬 환경`
- ┣ 즉 : `상위 스코프`를 가리킴
- ┗ 이를 통해 `단방향 링크드 리스트`인 : `스코프 체인을 구현`

- 현재 평가중인 소스코드 : `전역 코드`
- ┣ `전역 코드를 포함하는 소스코드는 없음`
- ┣ 전역 렉시컬 환경의` 외부 렉시컬 환경에 대한`
- ┣ `참조에 null이 할당`
- ┗ 전역 렉시컬 환경이 `스코프 체인의 종점에 존재`함 의미

### 26.6.3 전역 코드 실행

- 이제 `전역 코드가 순차적으로 실행`되기 시작
- ┣ `변수 할당문 실행` → 전역 변수 x,y에 값이 할당
- ┗ 그리고 `foo 함수가 호출`

- 변수 할당문 또는 함수 호출문을 실행하려면
- ┣ 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인
- ┗ 선언되지 않은 식별자 : 참조 X → 참조나 호출도 불가

- 식별자 : 스코프가 다르면 같은 이름을 가질 수 잇음
- ┣ 동일한 이름의 식별자가 다른 스코프에 여거래 존재 가능
- ┣ 어느 스코프의 식별자를 참조하면 되는지 결정할 필요 있음
- ┗ 이를 : `식별자 결정(identifier resolution)`

- `식별자 결정을 위한 식별자를 검색` :
- ┣ 실행중인 `실행 컨텍스트에서 식별자를 검색`하기 시작함
- ┣ `선언된 식별자` : `실행 컨텍스트의 렉시컬 환경` →
- ┗ `환경 레코드에 등록`되어 있음

- `현재 실행 중인 실행 컨텍스트` : 전역 실행 컨텍스트
- ┣ `전역 렉시컬 환경`에서 `식별자` x, y,foo를 `검색 시작`
- ┣ 만약 실`행 중인 실행 컨텍스트의 렉시컬 환경`에서
- ┣ `식별자를 검색할 수 없는 경우`
- ┣ `외부 렉시컬 환경`에 대한 참조가 가리키는 →
- ┗ 렉시컬 환경, 즉 : `상위 스코프로 이동하여 식별자 검색`

> 이것이 스코프 체인의 동작 원리

- `전역 렉시컬 환경` : `스코프 체인의 종점`
- ┣ `전역 렉시컬 환경에서 검색할 수 없는 식별자`는
- ┣ 참조 에러(ReferenceError)를 발생
- ┗ 식별자 결정에 실패했기 때문

> 실행 컨텍스트 : 소스코드를 실행하기 위해 필요한 환경을 제공
> 코드의 실행 결과를 실제로 관리하는 영역

### 23.6.4 foo 함수 코드 평가

- 예제 코드
- ┣ 현재 코드 평가를 통해 전역 실행 컨텍스트가 생성
- ┣ 전역 코드를 실행중
- ┗ 현재 진행 상황 : foo 함수 호출 전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10);
}

foo(20); // 호출 직전
```

- `foo 함수가 호출`되면 : 전역 코드의 실행을 `일시 중단`
- ┣ `foo 함수 내부`로 코드의 `제어권이 이동`
- ┣ 함수 코드를 `평가하기 시작`
- ┗ 함수 코드 평가는 다음과 같은 `순서`로 진행

1. 함수 실행 컨텍스트 생성

2. 함수 렉시컬 환경 생성
   - 2.1 함수 환경 레코드 생성
   - 2.2 this 바인딩
   - 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 함수 실행 컨텍스트 생성

- 먼저 foo 함수 `실행 컨텍스트를 생성`
- ┣ `생성된 컨텍스트` : 함수 렉시컬 환경이 완성된 다음
- ┣ `실행 컨텍스트 스택에 푸시`
- ┣ 이때 foo 함수 실행 컨텍스트 : 실행 컨텍스트 스태의
- ┗ 최상위 → `실행 중인 실행 컨텍스트(running execution context)`

#### 2. 함수 렉시컬 환경 생성

- foo 함수 `렉시컬 환경(Function Lexical Environment)`을 `생성`하고
- ┗ foo 함수 `실행 컨텍스트에 바인딩`

- 렉시컬 환경 : 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구성

##### 2.1 함수 환경 레코드 생성

- 함수 렉시컬 환경 구성의 함수 환경 레코드 :
- ┣ 1. `매개변수`, 2. `arguments 객체`, 3. `함수 내부에서 선언한 지역 변수`
- ┗ 4. `중첩 함수를 등록하고 관리`하게됨

##### 2.2 this 바인딩

- 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 this 바인딩
- ┣ `[[ThisValue]] 내부 슬롯에 바인딩될 객체`는
- ┗ 함수 호출 방식에 따라 결정됨

- foo 함수 : 일반 함수로 호출되었으므로 this : 전역 객체를 가리킴
- ┣ 함수 환경 레코드 `[[ThisValue]]` 내부 슬롯 → `전역 객체 바인딩`
- ┣ foo 함수 내부에서 this를 참조하면 함수 환경 `[[ThisValue]]`
- ┗ `내부 슬롯에 바인딩되어 있는 객체가 반환`


> 즉 : 함수 객체의 내부 슬롯 [[Environment]] :
> 렉시컬 스코프를 구현하는 매커니즘
> 이는 클로저를 이해하는 중요한 단서

### 23.6.5 foo 함수 코드 실행

- 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행
- ┣ 1. 매개변수에 인수가 할당되고, 2. 변수 할당문이 실행 →
- ┣ 지역 변수에 값이 할당
- ┗ 3. 함수 호출

- 이때 `식별자 결정을 위해` 실행 중인 `실행 컨텍스트`의
- ┣ `렉시컬 환경`에서 `식별자를 검색`하기 시작
- ┣ 현재 `실행 중인 실행 컨텍스트` : foo 함수 실행 컨텍스트
- ┗ foo 함수 `렉시컬 환경`에서 식별자 x,y를 검색하기 시작

- 만약 실행 컨텍스트에서 찾을 수 없으면
- ┣ `외부 렉시컬 환경에 대한 참조`가 가리키는
- ┣ `렉시컬 환경으로 이동`하여 `식별자를 검색`
- ┗ 검색된 식별자에 `값을 바인딩`

### 26.6.6 bar 함수 코드 평가

- 현재 foo 함수 코드 평가를 통해 → foo 함수 실행 컨텍스트 생성
- ┣ foo 함수 코드를 실행하고 있음
- ┗ 현재 : bar 함수를 호출하기 직전

```js
var x = 1;
const y = 2;

function foo(a) {
	var x = 3;
	const y = 4;

	function bar(b) {
		const z = 5;
		console.log(a + b + x + y + z);
	}
	bar(10); // 호출 직전
}
foo(20);
```

- `bar 함수가 호출`되면 → `bar 함수 내부`로 `코드의 제어권이 이동`
- ┣ `bar 함수 코드를 평가하기 시작`함
- ┣ `실행 컨텍스트`와 `렉시컬 환경의 생성 과정` :
- ┗ `foo 함수 코드 평가와 동일`
