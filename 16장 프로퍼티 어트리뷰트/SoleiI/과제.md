# [16장] 프로퍼티 어트리뷰트

### 16.1 내부 슬롯과 내부 메서드
자바스크립트 엔진의 내부 로직 → 직접 접근/호출 불가

e.g. `[[Prototype]]` 내부 슬롯은 `__proto__`를 통해 간접적으로 접근

### 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의
  - 프로퍼티의 상태: 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)
  - 프로퍼티 어트리뷰트: `[[Value]]`, `[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`
- `Object.getOwnPropertyDescriptor`: 프로퍼티 어트리뷰트를 간접적으로 확인 → 프로퍼티 디스크립터 객체 반환
```js
const person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.
console.log(Object.getOwnPropertyDescriptors(person));
/*
{
  name: {value: "Lee", writable: true, enumerable: true, configurable: true},
  age: {value: 20, writable: true, enumerable: true, configurable: true}
}
*/
```

### 16.3 데이터 프로퍼티와 접근자 프로퍼티
#### 데이터 프로퍼티
키와 값으로 구성된 일반적인 프로퍼티
<table>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
<tr>
<td><code>[[Value]]</code></td>
<td><code>value</code></td>
<td>
- 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값
<br/>- 프로퍼티 키를 통해 프로퍼티 값을 변경하면 <code>[[Value]]</code>에 값을 재할당 또는 동적 생성
</td>
</tr>
<tr>
<td><code>[[Writable]]</code></td>
<td><code>writable</code></td>
<td>
- 프로퍼티 값의 변경 가능 여부 → <code>boolean</code>
<br/>- <code>[[Writable]]</code>의 값이 <code>false</code>면 읽기 전용 프로퍼티
</td>
</tr>
<tr>
<td><code>[[Enumerable]]</code></td>
<td><code>enumerable</code></td>
<td>
- 프로퍼티의 열거 가능 여부 → <code>boolean</code>
<br/>- <code>[[Enumerable]]</code>의 값이 <code>false</code>면 <code>for...in</code> 문이나 <code>Object.keys</code> 메서드 사용 불가
</td>
</tr>
<tr>
<td><code>[[Configurable]]</code></td>
<td><code>configurable</code></td>
<td>- 프로퍼티의 재정의 가능 여부 → <code>boolean</code>
<br/>- <code>[[Configurable]]</code>의 값이 <code>false</code>면 해당 프로퍼티의 삭제 및 프로퍼티 어트리뷰트 값의 변경이 금지
<br/>단, <code>[[Writable]]</code>이 <code>true</code>인 경우 <code>[[Value]]</code>의 변경과 <code>[[Writable]]</code>을 <code>false</code>로 변경하는 것은 허용
</td>
</tr>
</table>

#### 접근자 프로퍼티
자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명
--|--|--
`[[Get]]` | `get` | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 → getter 함수 호출
`[[Set]]` | `set` | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 → setter 함수 호출
`[[Enumerable]]` | `enumerable` |
`[[Configurable]]` | `configurable` | 

접근자 함수: getter, setter 함수 → 모두 정의할 수도 있고 하나만 정의할 수도 있음

### 16.4 프로퍼티 정의
새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것 → `Object.defineProperty` 또는 `Object.defineProperties`로 정의

*cf)* `Object.defineProperty`로 프로퍼티를 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있음

프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본값
--|--|--
`value` | `[[Value]]` | undefined
`get` | `[[Get]]` | undefined
`set` | `[[Set]]` | undefined
`writable` | `[[Writable]]` | false
`enumerable` | `[[Enumerable]]` | false
`configurable` | `[[Configurable]]` | false

### 16.5 객체 변경 방지
#### 객체 변경 방지 메서드
구분 | 메서드 | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의
--|--|-|--|--|--|--
객체 확장 금지 | `Object.preventExtensions` | X | O | O | O | O
객체 밀봉 | `Object.seal` | X | X | O | O | X
객체 동결 | `Object.freeze` | X | X | O | X | X

- 객체 확장 금지 → 확장 가능 여부는 `Object.isExtensible` 메서드로 확인
- 객체 밀봉 → 밀봉 여부는 `Object.isSealed` 메서드로 확인
- 객체 동결 → 동결 여부는 `Object.isFrozen` 메서드로 확인

#### 불변 객체
- 변경 방지 메서드들은 얕은 변경 방지 → 직속 프로퍼티만 변경 방지되고 중첩 객체에는 영향을 주지 못함
- 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 `Object.freeze` 메서드를 호출해야 함
```js
function deepFreeze(target) {
  // 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.
  if (target && typeof target === 'object' && !Object.isFrozen(target)) {
    Object.freeze(target);
    /*
      모든 프로퍼티를 순회하며 재귀적으로 동결한다.
      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.
      ("19.15.2. Object.keys/values/entries 메서드" 참고)
      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.
      ("27.9.2. Array.prototype.forEach" 참고)
    */
    Object.keys(target).forEach(key => deepFreeze(target[key]));
  }
  return target;
}

const person = {
  name: 'Lee',
  address: { city: 'Seoul' }
};

// 깊은 객체 동결
deepFreeze(person);

console.log(Object.isFrozen(person)); // true
// 중첩 객체까지 동결한다.
console.log(Object.isFrozen(person.address)); // true

person.address.city = 'Busan';
console.log(person); // {name: "Lee", address: {city: "Seoul"}}
```